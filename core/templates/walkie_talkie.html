<!doctype html>
<html>
<head>
    <meta charset="utf-8">
    <title>Walkie Talkie - {{ event.event_name }}</title>
    <style>
        body {
            background: #0b0f14;
            font-family: sans-serif;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            min-height: 100vh;
            color: #fff;
        }

        h1 { margin-bottom: 20px; }

        /* Container to center button */
        .ptt-container {
            display: flex;
            justify-content: center;
            align-items: center;
            position: relative;
        }

        /* Circular button */
        .ptt {
            width: 140px;
            height: 140px;
            background: radial-gradient(circle at 30% 30%, #4ade80, #22c55e);
            border: none;
            border-radius: 50%;
            color: #fff;
            font-size: 1rem;
            font-weight: bold;
            cursor: pointer;
            box-shadow: 0 0 20px rgba(34,197,94,0.6), 0 8px 20px rgba(0,0,0,0.5);
            transition: transform 0.1s ease, box-shadow 0.2s ease;
            position: relative;
            z-index: 2;
        }

        /* Press effect */
        .ptt:active {
            transform: scale(0.92);
            box-shadow: 0 0 10px rgba(34,197,94,0.7), inset 0 0 15px rgba(0,0,0,0.5);
        }
    </style>
</head>
<body>
    <div class="panel">
        <h1>Walkie-Talkie</h1>
        <h3>Event: {{ event.event_name }}</h3>
        <p>Your peer id: <strong id="myPeer">{{ my_peer_id }}</strong></p>
        <p>Logged in as volunteer phone: <strong>{{ phone }}</strong></p>

        <button id="connectBtn">Connect to Peers</button>
        <div class="ptt-containerd">
            <button class="ptt" id="holdBtn" hidden>Hold to Talk</button>
        </div>
        
        <div class="peers">
            <h3 hidden>Peers</h3>
            <ul id="peersList"></ul>
        </div>
    </div>

<!-- PeerJS CDN -->
<script src="https://unpkg.com/peerjs@1.4.7/dist/peerjs.min.js"></script>
<script>
(function(){
    const myPeerId = '{{ my_peer_id }}';
    const otherPeers = JSON.parse('{{ other_peers_json|escapejs }}');

    const connectBtn = document.getElementById('connectBtn');
    const ptt = document.getElementById('ptt');
    const peersList = document.getElementById('peersList');
    const btnText = document.getElementById('holdBtn');

    let peer = null;
    let localStream = null;
    let openConnections = {};

    function logStatus(s){ btnText.innerText = s; }

    function addPeerToList(id){
        const li = document.createElement('li');
        li.textContent = id;
        li.id = 'peer-' + id;
        peersList.appendChild(li);
        if (peersList.children.length > 0){
            peersList.previousElementSibling.hidden = false; // show "Peers" header
        } else {
            peersList.previousElementSibling.hidden = true; // hide "Peers" header
        }
    }

    function removePeerFromList(id){
        const el = document.getElementById('peer-' + id);
        if(el) el.remove();
        if (peersList.children.length > 0){
            peersList.previousElementSibling.hidden = false; // show "Peers" header
        } else {
            peersList.previousElementSibling.hidden = true; // hide "Peers" header
        }
    }

    async function ensureMicrophone(){
        if(localStream) return localStream;
        try{
            localStream = await navigator.mediaDevices.getUserMedia({ audio: true });
            return localStream;
        }catch(err){
            alert('Microphone access is required for walkie-talkie.');
            throw err;
        }
    }

    connectBtn.addEventListener('click', async function(){
        if(peer) return;
        logStatus('initializing peer');
        connectBtn.hidden = true;
        btnText.hidden = false
        peer = new Peer(myPeerId, { debug: 2 });
        logStatus('Hold to Talk');

        peer.on('open', id => {
            // show peers
            otherPeers.forEach(p => addPeerToList(p));
        });

        peer.on('call', call => {
            // when someone calls us, answer with our microphone (receive audio)
            call.answer(null); // answer without sending stream (we'll only send when talking)
            call.on('stream', remoteStream => {
                // play remote audio
                const audio = document.createElement('audio');
                audio.srcObject = remoteStream;
                audio.autoplay = true;
                audio.controls = false;
                document.body.appendChild(audio);
            });
        });

        peer.on('error', err => {
            console.error(err); logStatus('peer error');
        });

        // Pre-place calls to peers so incoming audio is available quickly
        for(const pid of otherPeers){
            try{
                const call = peer.call(pid, null); // no stream now
                openConnections[pid] = call;
                call.on('stream', remoteStream => {
                    const audio = document.createElement('audio');
                    audio.srcObject = remoteStream;
                    audio.autoplay = true;
                    document.body.appendChild(audio);
                });
            }catch(e){
                console.warn('call failed to', pid, e);
            }
        }
    });

    // Push-to-talk behavior: while held, get mic and send stream to all peers
    ptt.addEventListener('mousedown', async () => {
        try{
            // logStatus('getting mic...');
            const stream = await ensureMicrophone();
            logStatus('sending audio');
            // For each peer, call with stream
            for(const pid of otherPeers){
                try{
                    // Close previous call if exists
                    if(openConnections[pid] && openConnections[pid].close) openConnections[pid].close();
                    const call = peer.call(pid, stream);
                    openConnections[pid] = call;
                }catch(e){ console.warn(e); }
            }
        }catch(e){ logStatus('mic denied'); }
    });
    ptt.addEventListener('mouseup', () => {
        logStatus('Hold to Speak');
        holdBtn.innerText = "Talking..."
        // stop sending: close outgoing calls and stop tracks
        for(const pid in openConnections){
            try{ openConnections[pid].close(); }catch(e){}
            delete openConnections[pid];
        }
        if(localStream){
            localStream.getTracks().forEach(t => t.stop());
            localStream = null;
        }
    });

    // mobile touch events
    ptt.addEventListener('touchstart', async (e) => { e.preventDefault(); ptt.dispatchEvent(new Event('mousedown')); });
    ptt.addEventListener('touchend', (e) => { e.preventDefault(); ptt.dispatchEvent(new Event('mouseup')); });

})();
</script>
</body>
</html>